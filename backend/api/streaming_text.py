"""
Text Streaming for Multi-Agent Analysis
Streams LLM responses word-by-word as they're generated
"""

from typing import AsyncGenerator, Dict, Any
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage
import os
import logging

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


async def stream_agent_analysis(
    agent_name: str, system_prompt: str, user_prompt: str, model: str = "gpt-4o-mini"
) -> AsyncGenerator[Dict[str, Any], None]:
    """
    Stream an agent's analysis text as it's generated by the LLM.

    Args:
        agent_name: Name of the agent (e.g., "Market Analyst")
        system_prompt: System message for the agent
        user_prompt: User message/question for the agent
        model: LLM model to use

    Yields:
        Events with text chunks:
        - agent_text_chunk: Individual text chunk
        - agent_text_complete: Full text when done
    """
    # Initialize streaming LLM
    llm = ChatOpenAI(
        model=model,
        temperature=0.3,
        streaming=True,  # Enable streaming
        api_key=os.getenv("OPENAI_API_KEY"),
    )

    full_text = ""

    # Start streaming
    logger.info(f"üöÄ [{agent_name}] Starting text streaming...")
    yield {
        "event": "agent_text_start",
        "agent": agent_name,
        "message": f"{agent_name} is analyzing...",
    }

    try:
        # Stream the response
        logger.info(f"üì° [{agent_name}] Calling LLM (model={model})...")
        chunk_count = 0
        async for chunk in llm.astream(
            [SystemMessage(content=system_prompt), HumanMessage(content=user_prompt)]
        ):
            if chunk.content:
                chunk_count += 1
                full_text += chunk.content

                # Yield each chunk
                yield {
                    "event": "agent_text_chunk",
                    "agent": agent_name,
                    "chunk": chunk.content,
                    "accumulated_length": len(full_text),
                }

        # Analysis complete
        logger.info(
            f"‚úÖ [{agent_name}] Streaming complete! Received {chunk_count} chunks, {len(full_text)} characters"
        )
        yield {
            "event": "agent_text_complete",
            "agent": agent_name,
            "full_text": full_text,
            "total_length": len(full_text),
        }

    except Exception as e:
        logger.error(f"‚ùå [{agent_name}] Error during streaming: {e}")
        yield {"event": "agent_error", "agent": agent_name, "error": str(e)}


async def stream_stock_analysis_with_text(
    symbol: str, trading_agents_graph, trade_date: str
) -> AsyncGenerator[Dict[str, Any], None]:
    """
    Stream complete stock analysis with real-time text streaming.

    This version streams the actual LLM responses as they're generated,
    not just progress updates.
    """
    try:
        logger.info(
            f"üéØ ========== STARTING MULTI-AGENT ANALYSIS FOR {symbol} =========="
        )
        yield {
            "event": "start",
            "symbol": symbol,
            "message": f"Starting multi-agent analysis for {symbol}",
            "timestamp": trade_date,
        }

        # Agent configurations
        logger.info(f"üìã [{symbol}] Configured 4 agents for analysis")
        agents = [
            {
                "name": "Market Analyst",
                "system": "You are a veteran market analyst with expertise in technical analysis, chart patterns, and market trends.",
                "prompt": f"Analyze {symbol} from a technical perspective. Include: price action, key indicators (RSI, MACD), support/resistance levels, and trend analysis.",
            },
            {
                "name": "Social Analyst",
                "system": "You are a social media sentiment analyst tracking retail investor psychology and crowd behavior.",
                "prompt": f"Analyze social sentiment for {symbol}. Include: Reddit discussions, Twitter mentions, StockTwits activity, and overall retail sentiment.",
            },
            {
                "name": "News Analyst",
                "system": "You are a news analyst tracking breaking news, corporate events, and market-moving catalysts.",
                "prompt": f"Analyze recent news and events for {symbol}. Include: latest headlines, insider trading, corporate actions, and upcoming catalysts.",
            },
            {
                "name": "Fundamentals Analyst",
                "system": "You are a fundamental analyst evaluating financial health, valuation, and growth prospects.",
                "prompt": f"Analyze {symbol}'s fundamentals. Include: financial ratios, earnings trends, valuation metrics, and competitive position.",
            },
        ]

        agent_results = {}

        # Stream each agent's analysis
        for i, agent_config in enumerate(agents):
            agent_name = agent_config["name"]
            progress = (i / len(agents)) * 100

            logger.info(
                f"üìä [{symbol}] Agent {i+1}/{len(agents)}: {agent_name} starting (progress: {progress:.0f}%)"
            )
            yield {"event": "agent_start", "agent": agent_name, "progress": progress}

            # Stream the agent's text analysis
            full_text = ""
            async for text_event in stream_agent_analysis(
                agent_name=agent_name,
                system_prompt=agent_config["system"],
                user_prompt=agent_config["prompt"],
            ):
                # Forward text streaming events
                yield text_event

                # Accumulate full text
                if text_event["event"] == "agent_text_complete":
                    full_text = text_event["full_text"]
                    logger.info(
                        f"üìù [{symbol}] {agent_name} completed: {len(full_text)} chars"
                    )

            agent_results[agent_name.lower().replace(" ", "_")] = full_text

            progress = ((i + 1) / len(agents)) * 100
            logger.info(
                f"‚úÖ [{symbol}] Agent {i+1}/{len(agents)}: {agent_name} complete (progress: {progress:.0f}%)"
            )
            yield {"event": "agent_complete", "agent": agent_name, "progress": progress}

        # Synthesis phase
        logger.info(f"üî¨ [{symbol}] Starting synthesis phase (90% complete)...")
        yield {"event": "synthesis_start", "message": "Synthesizing agent reports..."}

        # Create synthesis prompt
        logger.info(
            f"üìÑ [{symbol}] Creating synthesis prompt from {len(agent_results)} agent reports"
        )
        synthesis_prompt = f"""
Based on the analysis from all agents, provide a final recommendation for {symbol}.

Market Analysis: {agent_results.get('market_analyst', 'N/A')[:200]}...
Social Sentiment: {agent_results.get('social_analyst', 'N/A')[:200]}...
News Analysis: {agent_results.get('news_analyst', 'N/A')[:200]}...
Fundamentals: {agent_results.get('fundamentals_analyst', 'N/A')[:200]}...

Provide: BUY/SELL/HOLD recommendation with justification.
"""

        # Stream synthesis
        logger.info(f"ü§ñ [{symbol}] Calling Investment Synthesizer agent...")
        synthesis_text = ""
        async for synthesis_event in stream_agent_analysis(
            agent_name="Investment Synthesizer",
            system_prompt="You are a Chief Investment Officer synthesizing multiple analyst perspectives into actionable recommendations.",
            user_prompt=synthesis_prompt,
        ):
            yield synthesis_event

            if synthesis_event["event"] == "agent_text_complete":
                synthesis_text = synthesis_event["full_text"]
                logger.info(
                    f"‚úÖ [{symbol}] Synthesis complete: {len(synthesis_text)} chars"
                )

        # Determine recommendation from synthesis
        logger.info(f"üîç [{symbol}] Parsing recommendation from synthesis...")
        recommendation = "HOLD"
        if "BUY" in synthesis_text.upper() and synthesis_text.upper().find(
            "BUY"
        ) < synthesis_text.upper().find(
            "SELL",
            (
                synthesis_text.upper().find("BUY") + 1
                if "SELL"
                in synthesis_text.upper()[synthesis_text.upper().find("BUY") :]
                else len(synthesis_text)
            ),
        ):
            recommendation = "BUY"
        elif "SELL" in synthesis_text.upper():
            recommendation = "SELL"

        logger.info(f"üìä [{symbol}] Recommendation determined: {recommendation}")

        # Get price data
        logger.info(f"üí∞ [{symbol}] Fetching current price data from yfinance...")
        import yfinance as yf

        ticker_data = yf.Ticker(symbol.upper())
        current_price = (
            ticker_data.history(period="1d")["Close"].iloc[-1]
            if not ticker_data.history(period="1d").empty
            else 100.0
        )

        logger.info(f"üíµ [{symbol}] Current price: ${current_price:.2f}")

        target_price = (
            current_price * 1.15 if recommendation == "BUY" else current_price
        )
        stop_loss = (
            current_price * 0.95 if recommendation == "BUY" else current_price * 0.90
        )

        # Calculate bull/base/bear case prices
        bull_case_price = current_price * 1.25
        base_case_price = current_price * 1.10
        bear_case_price = current_price * 0.90

        logger.info(
            f"üéØ [{symbol}] Target: ${target_price:.2f}, Stop Loss: ${stop_loss:.2f}"
        )
        logger.info(
            f"üìä [{symbol}] Bull: ${bull_case_price:.2f}, Base: ${base_case_price:.2f}, Bear: ${bear_case_price:.2f}"
        )

        # Final result
        logger.info(
            f"‚úÖ [{symbol}] ========== ANALYSIS COMPLETE - SENDING 'done' EVENT =========="
        )
        yield {
            "event": "done",
            "symbol": symbol.upper(),
            "recommendation": recommendation,
            "overall_recommendation": recommendation,
            "confidence": 0.80,
            "target_price": float(target_price),
            "stop_loss": float(stop_loss),
            "current_price": float(current_price),
            "price_targets": {
                "bull_case": float(bull_case_price),
                "base_case": float(base_case_price),
                "bear_case": float(bear_case_price),
            },
            "agents": {
                "market_analyst": {
                    "recommendation": recommendation,
                    "reasoning": agent_results.get("market_analyst", "")[:200] + "...",
                    "confidence": 0.8,
                },
                "social_analyst": {
                    "recommendation": recommendation,
                    "reasoning": agent_results.get("social_analyst", "")[:200] + "...",
                    "confidence": 0.75,
                },
                "news_analyst": {
                    "recommendation": recommendation,
                    "reasoning": agent_results.get("news_analyst", "")[:200] + "...",
                    "confidence": 0.8,
                },
                "fundamentals_analyst": {
                    "recommendation": recommendation,
                    "reasoning": agent_results.get("fundamentals_analyst", "")[:200]
                    + "...",
                    "confidence": 0.85,
                },
            },
            "agent_reports": agent_results,
            "debate_summary": synthesis_text,
            "synthesis": synthesis_text,
            "timestamp": trade_date,
        }
        logger.info(f"üéâ [{symbol}] 'done' event sent successfully!")

    except Exception as e:
        logger.error(f"‚ùå [{symbol}] ERROR in stream_stock_analysis_with_text: {e}")
        logger.exception(e)  # This will print the full stack trace
        yield {"event": "error", "symbol": symbol, "message": str(e)}
